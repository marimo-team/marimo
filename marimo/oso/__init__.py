# OSO Extensions for marimo
from ast import parse
import json
import typing as t

from marimo._ast import names
from marimo._pyodide.pyodide_session import PyodideBridge, PyodideSession
from marimo._schemas.serialization import (
    CellDef,
    NotebookSerializationV1
)
from marimo._convert.converters import MarimoConvert


def initialize_env(env: dict[str, str]) -> None:
    print("Initializing OSO notebook env vars")
    import os

    for key, value in env.items():
        print(f"   Setting env var {key}")
        os.environ[key] = value


SETUP_PYOSO_CODE = """
# This code sets up pyoso to be used as a database provider for this notebook
# This code is autogenerated. Modification could lead to unexpected results :)
import pyoso
pyoso_db_conn = pyoso.Client().dbapi_connection()
"""


class InterceptingPyodideBridge(PyodideBridge):
    FUNCTIONS: dict[str, t.Callable[..., None]] = {
        "__oso_initialize_env": initialize_env
    }

    @classmethod
    def from_parent(cls, bridge: PyodideBridge) -> "InterceptingPyodideBridge":
        return cls(session=bridge.session)

    def put_control_request(self, request: str):
        """For OSO specific injection, we intercept the FunctionRequest control request
        
        To do this we parse the request string as json
        """
        print("Intercepting PyodideBridge control request")
        try:
            json_data = json.loads(request)
        except json.JSONDecodeError:
            return super().put_control_request(request)
        
        
        function_call_id = json_data.get("functionCallId", "")
        function_name = json_data.get("functionName", "")
        args = json_data.get("args", {})
        namespace = json_data.get("namespace", "")

        if namespace != "marimo.oso":
            return super().put_control_request(request)

        print("overriding a function call")

        # Here we can add OSO specific handling
        # For example, we could modify the function call in some way
        # or add additional metadata to the request
        if function_name in self.FUNCTIONS:
            # Call the registered function with the provided arguments
            return self.FUNCTIONS[function_name](**args)
        else:
            return super().put_control_request(request)
        

def ensure_pyoso_setup(notebook_contents: str):
    """Ensures that pyoso is setup in the notebook."""

    from marimo._ast.parse import parse_notebook

    parsed_notebook = parse_notebook(notebook_contents)
    if not parsed_notebook:
        raise ValueError("Failed to parse notebook.")
    
    # Check if the setup_pyoso cell is present. If not, add it and write out the resulting notebook
    setup_pyoso_index = 0
    for cell in parsed_notebook.cells:
        if cell.name == "setup_pyoso":
            return notebook_contents
        setup_pyoso_index += 1

    # If the setup_pyoso cell was not found, add it to the beginning by
    # generating a new notebook intermediate representation. See
    # marimo._ast.app.InternalApp#to_ir() for reference on how to do this.

    cells: list[CellDef] = [
        CellDef(
            code=SETUP_PYOSO_CODE,
            name="setup_pyoso",
            options={}
        )
    ]
    for cell in parsed_notebook.cells:
        cells.append(CellDef(
            code=cell.code,
            name=cell.name,
            options=cell.options,
        ))

    return MarimoConvert.from_ir(
        NotebookSerializationV1(
            cells=cells,
            app=parsed_notebook.app,
        )
    ).to_py()

def ensure_pyoso_setup_in_file(path: str) -> None:
    """Ensures that pyoso is setup in the notebook at the given path."""
    with open(path, "r") as f:
        contents = f.read()
    
    new_contents = ensure_pyoso_setup(contents)
    if new_contents != contents:
        with open(path, "w") as f:
            f.write(new_contents)